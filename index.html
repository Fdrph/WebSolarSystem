<!DOCTYPE html>
<html>
<head>
<title>Solar System</title>
<link rel="stylesheet" href="proj2.css">
<script type="module" src="proj2.js"></script>
<!-- ------------------------ GOURAUD ------------------------ -->
<script id="gouraud-vertex" type="x-shader/x-vertex">
//uniform mat4 viewMatrix;
//uniform mat4 modelViewMatrix;
//uniform mat4 projectionMatrix;
//uniform mat3 normalMatrix;

uniform vec3  lightPos;
uniform vec3  lightCol;
uniform float lightI;
uniform float shininess;
uniform float ambient;

//attribute vec3 position;
//attribute vec3 normal;
//attribute vec2 uv;
    
//varying vec3 vertPosition;
varying vec3 vertColor;
varying vec3 normalV;

void main()
{
    // normal vector in view space
    vec3 N = normalize( normalMatrix * normal );
    
    // view direction in view space
    vec3 vertPos = vec3(modelViewMatrix * vec4( position, 1.0 ));
    vec3 eyeV = normalize( -vertPos );

    // light direction in view space
    vec3 lightPos = vec3(viewMatrix * vec4(lightPos, 1.0));
    vec3 L = normalize(lightPos - vertPos);

    // blinn-phong
    float lambert = max(dot(N,L), 0.0);
    vec3 H = normalize( eyeV + L);
    float specular = pow(max(dot(N,H), 0.0), shininess) * lambert;

    vec3 diffuseCol = lightCol;
    vertColor     = (ambient * diffuseCol) + (lambert * diffuseCol * lightI) + (specular * lightCol * lightI);
    gl_Position   = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script id="gouraud-fragment" type="x-shader/x-fragment">
varying vec3 vertColor;
varying vec3 normalV;

void main() 
{
    gl_FragColor = vec4(vertColor, 1.0);
}
</script>
<!-- ------------------------ PHONG ------------------------ -->
<script id="phong-vertex" type="x-shader/x-vertex">
    //uniform mat4 viewMatrix;
    //uniform mat4 modelViewMatrix;
    //uniform mat4 projectionMatrix;
    //uniform mat3 normalMatrix;
    
    uniform vec3  lightPos;
    uniform vec3  lightCol;
    uniform float lightI;
    uniform float specI;
    uniform float shininess;
    uniform float ambient;
    uniform float useNormal;
    uniform float normalStrength;
    
    //attribute vec3 position;
    //attribute vec3 normal;
    //attribute vec2 uv;
    attribute vec4 tangent;
        
    varying vec3 vertPos;
    varying vec3 vNormal;
    varying vec2 texUV;
    varying vec3 vTangent;
    varying vec3 vBiTangent;
    
    void main()
    {
        vNormal = normalMatrix * normalize(normal);
        vertPos = vec3(modelViewMatrix * vec4( position, 1.0 ));
        texUV = uv;
        vTangent = normalize( normalMatrix * tangent.xyz);
        vBiTangent = cross( vNormal, vTangent);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
<script id="phong-fragment" type="x-shader/x-fragment">
    uniform vec3  lightPos;
    uniform vec3  lightCol;
    uniform float lightI;
    uniform float specI;
    uniform float shininess;
    uniform float ambient;
    uniform float useNormal;
    uniform float normalStrength;
    uniform float exposure;
    uniform sampler2D tex;
    uniform sampler2D texNormal;
    
    varying vec3 vertPos;
    varying vec3 vNormal;
    varying vec2 texUV;
    varying vec3 vTangent;
    varying vec3 vBiTangent;

    
    vec3 RRTAndODTFitt( vec3 v ) {
        vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
        vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
        return a / b;
    }

    vec3 ACESToneMapping( vec3 color ) {
        const mat3 ACESInputMat = mat3(
            vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ),
            vec3( 0.04823, 0.01566, 0.83777 )
        );
        const mat3 ACESOutputMat = mat3(
            vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108,  1.10813, -0.07276 ),
            vec3( -0.07367, -0.00605,  1.07602 )
        );
        color *= exposure / 0.6;
        color = ACESInputMat * color;
        color = RRTAndODTFitt( color );
        color = ACESOutputMat * color;
        return clamp( color, 0.0, 1.0 );
    }

    void main()
    {
        // normal from normal map
        vec3 N = normalize( vNormal );
        if (useNormal > 0.5) {
            vec3 n = texture2D( texNormal, texUV).xyz * 2.0 - 1.0;
            n.xy *= normalStrength;
            mat3 TBN = mat3(normalize(vTangent), normalize(vBiTangent), normalize(vNormal));
            N = TBN * normalize(n);
        }

        // view direction in view space
        vec3 eyeV = normalize( -vertPos );
    
        // light direction in view space
        vec3 lightPos = vec3(viewMatrix * vec4(lightPos, 1.0));
        vec3 L = normalize(lightPos - vertPos);
    
        // blinn-phong
        float lambert = max(dot(N,L), 0.0);
        vec3 H = normalize( eyeV + L);
        float specular = pow(max(dot(N,H), 0.0), shininess) * lambert;
    
        vec3 diffuseCol = vec3(sRGBToLinear(texture2D(tex, texUV)));
        vec3 fragColor = (ambient * diffuseCol) + (lambert * diffuseCol * lightI) + (specular * lightCol * specI);
        fragColor = ACESToneMapping(fragColor);
        gl_FragColor = LinearToGamma(vec4(fragColor,1.0),2.2);
    }
</script>
<script id="skydome-vertex" type="x-shader/x-vertex">
    varying vec2 fUV;
    void main(){ fUV = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
</script>
<script id="skydome-fragment" type="x-shader/x-fragment">
    uniform sampler2D sky;
    uniform float accurate;
    varying vec2 fUV;

    float exposure = 0.0015;

    vec3 RRTAndODTFitt( vec3 v ) {
        vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
        vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
        return a / b;
    }

    vec3 ACESToneMapping( vec3 color ) {
        const mat3 ACESInputMat = mat3(
            vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ),
            vec3( 0.04823, 0.01566, 0.83777 )
        );
        const mat3 ACESOutputMat = mat3(
            vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108,  1.10813, -0.07276 ),
            vec3( -0.07367, -0.00605,  1.07602 )
        );
        color *= exposure / 0.6;
        color = ACESInputMat * color;
        color = RRTAndODTFitt( color );
        color = ACESOutputMat * color;
        return clamp( color, 0.0, 1.0 );
    }

    void main()
    { 
        vec3 fragColor = vec3(sRGBToLinear(texture(sky, fUV)));
        fragColor *= 100.0;
        fragColor = ACESToneMapping(fragColor);
        gl_FragColor = LinearToGamma(vec4(fragColor,1.0),2.2);
    }
</script>
<script id="sun-vertex" type="x-shader/x-vertex">
void main(){ gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
</script>
<script id="sun-fragment" type="x-shader/x-fragment">
void main(){ gl_FragColor = vec4(1.0,0.949,0.929,1.0); }
</script>
</head>
<body>
<div id="loading">Loading...</div>
<div id="options-panel" style="background-color: rgba(14, 14, 14, 0.6)">
    <h1 class="options-header">Options</h1>
    <!--  -->
    <div class="option-border"></div>
    <div class="checkmark-option">
        <div class="checkmark-title">Show Orbits</div>
        <div class="checkmark-container">
            <label class="container">
                <input type="checkbox" id="draw-orbits" checked>
                <span class="checkmark"></span>
            </label>
        </div>
    </div>
    <div class="checkmark-option">
        <div class="checkmark-title">Show Rotation Axis</div>
        <div class="checkmark-container">
            <label class="container">
                <input type="checkbox" id="draw-north-poles">
                <span class="checkmark"></span>
            </label>
        </div>
    </div>
    <!--  -->
    <div class="option-border"></div>
    <h1 class="options-header">Go To</h1>
    <div class="option-border"></div>
    <div class="gotoplanet">Mercury</div>
    <div class="gotoplanet">Venus</div>
    <div class="gotoplanet">Earth</div>
    <div class="gotoplanet">Moon</div>
    <div class="gotoplanet">Mars</div>
    <div class="gotoplanet">Jupiter</div>
    <div class="gotoplanet">Saturn</div>
    <div class="gotoplanet">Uranus</div>
    <div class="gotoplanet">Neptune</div>
</div>
</body>
</html>


<!-- Sources: -->
<!-- https://svs.gsfc.nasa.gov/4851 -->
<!-- https://svs.gsfc.nasa.gov/cgi-bin/details.cgi?aid=4720 -->
<!-- https://asa.hmnao.com/ -->
<!-- https://learnopengl.com/Advanced-Lighting/Normal-Mapping -->
<!-- https://ssd.jpl.nasa.gov/horizons/app.html#/ -->
<!-- https://aa.quae.nl/en/reken/hemelpositie.html -->
<!-- https://www.researchgate.net/publication/316558298_Date_Algorithms -->